# [RFC] Moving services discovery out of the playlist

## Context

The playlist manages a lot of different intricated things, that could be
separated.

For VLC 4, we would like to change the way the playlist work: it should be a
simple list containing items to be played. No more trees.

One purpose is that _services discoveries_ components should not behave like a
playlist anymore: if one item does not work, the next item should not be played.
Instead, clicking on an item should add it to the playlist.

For that purpose, we would like to separate services discoveries from the
playlist.

## Current state

Currently, the playlist is responsible for services discoveries at different
levels:
 1. it manages adding/removing SD
 2. it stores the input items generated by the SD into its tree
 3. it is used by UI models to display the SD content


## Proposal

_Since the API will be used by several interfaces (at least Qt and MacOS), it is
a CORE API._


### Media source manager

The idea is to manage _media sources_ from a _media source manager_ (called
[`media_browser_t`][vlc_media_browser.h] for now), separated from the playlist.

In the module tree, the _media source manager_ would be a child of _libvlc_
rather than the playlist. Several interfaces should be able to use it
simultaneously.

Each _media source_ contains a [_media tree_][vlc_media_tree.h] and some
metadata:

```c
typedef struct media_source_t
{
    media_tree_t *p_tree;
    const char *psz_description;
} media_source_t;
```

A _media source_ can be retrieved via a single method of the _media browser_
(think _media source manager_):

```c
VLC_API media_source_t *media_browser_GetMediaSource( media_browser_t *, const char *psz_name );
```

Requesting a _services discovery_ that is not open will automatically open it.
If several "clients" request the same _media source_ (i.e. requesting the same
name), they will receive the same `media_source_t` instance.

A _media source_ is ref-counted:

```c
VLC_API void media_source_Hold( media_source_t * );
VLC_API void media_source_Release( media_source_t * );
```

As soon as a _media source_ is released by all its clients, the associated
_services discovery_ is closed.

The WIP implementation is [`media_browser.c`][media_browser.c].

[vlc_media_browser.h]: include/vlc_media_browser.h
[media_browser.c]: src/media_browser/media_browser.c

### Media tree

The items provided by the services discovery are now stored in a _media tree_,
independant of the playlist.

Note that a _media tree_ represents any tree of media (_input items_): it is
totally independant of the _media browser_/_media source manager_/_service
discovery_ stuff.

A _media tree_ is an object with a root node:

```c
typedef struct media_node_t media_node_t;
typedef struct media_tree_t media_tree_t;
TYPEDEF_ARRAY( media_node_t *, media_node_array_t )

struct media_node_t
{
    input_item_t *p_input;
    media_node_t *p_parent;
    media_node_array_t children;
};

struct media_tree_t {
    struct vlc_common_members obj;
    media_node_t p_root;
};
```

It is ref-counted:

```c
VLC_API void media_tree_Hold( media_tree_t * );
VLC_API void media_tree_Release( media_tree_t * );
```

It is externally lockable, so that clients can apply several changes to its
content atomically:

```c
VLC_API void media_tree_Lock( media_tree_t * );
VLC_API void media_tree_Unlock( media_tree_t * );
```

```c
/* media_tree must be locked */
VLC_API media_node_t *media_tree_Find( media_tree_t *, input_item_t * );
```

Clients may (and typically, will) connect listeners to be notified of content
changes:

```c
typedef struct media_tree_callbacks_t
{
    void ( *pf_tree_connected )( media_tree_t *, void *userdata );
    void ( *pf_subtree_added )( media_tree_t *, media_node_t *, void *userdata );
    void ( *pf_node_added )( media_tree_t *, media_node_t *, void *userdata );
    void ( *pf_node_removed )( media_tree_t *, media_node_t *, void *userdata );
    void ( *pf_input_updated )( media_tree_t *, media_node_t *, void *userdata );
} media_tree_callbacks_t;
```

The `pf_tree_connected()` is useful to get the initial state of the tree when
connecting a listener after initialization. In general, it may be a new
interface started at any time, while the _services discovery_ is already open.
Some _services discoveries_ also notify items added even before the _service
discovery_ `Open()` returns. Adding a listener after the creation would miss
these events without this callback.

Default implementations are provided for `pf_tree_connected` and
`pf_subtree_added`, which call `pf_node_added` for every node:

```c
VLC_API void media_tree_connected_default( media_tree_t *, void *userdata );
VLC_API void media_tree_subtree_added_default( media_tree_t *, media_node_t *, void *userdata );
```

A client might set its own implementation instead, for performance reasons
(typically, we don't want to add and notify every item one by one in Qt).

`pf_subtree_added()` and `pf_input_updated()` are events caused by the
underlying input item [events][vlc_event_type_t].

[vlc_event_type_t]: include/vlc_events.h#L99


To connect/disconnect listeners:

```c
typedef struct media_tree_connection_t media_tree_connection_t;

VLC_API media_tree_connection_t *media_tree_Connect( media_tree_t *, const media_tree_callbacks_t *, void *userdata );
VLC_API void media_tree_Disconnect( media_tree_t *, media_tree_connection_t * );
```

_(naming inspired by [Qt][qobject-connect])_

The `media_tree_connection_t *` is just an opaque handle to identify the
listener to remove.

[qobject-connect]: https://doc.qt.io/qt-5/qobject.html#connect-4

The WIP implementation is [`media_tree.c`][media_tree.c].

[vlc_media_tree.h]: include/vlc_media_tree.h
[media_tree.c]: src/media_tree/media_tree.c


### UI

The future UI would use _media trees_ instead of the playlist (currently, in
[`PLModel`][playlist_model.hpp] for Qt).

As an incremental step, in order not to break the current UI, I made the
playlist a client of this new API, so that every changes applied to the _media
trees_ are [`reflected`][services_discovery.c] to the playlist, so the media are
still displayed in the UI.


[playlist_model.hpp]: modules/gui/qt/components/playlist/playlist_model.hpp
[services_discovery.c]: src/playlist/services_discovery.c


### Browsing/preparsing

When a new input item is added, we need to _preparse_ it to get more information
(name, duration, etc.). On user request, we also need to be able to _browse_
some items (e.g., opening a folder using Samba).

Both features are provided by
[`libvlc_MetadataRequest()`][libvlc_MetadataRequest]. They trigger input item
events, which are handled by the _media tree_, so the _media tree_ will
automatically update and notify its client.

All the preparsing stuff is still implemented in the playlist code for now, but
it can/will be moved/refactored independently.

[libvlc_MetadataRequest]: https://github.com/rom1v/vlc/blob/mb/src/libvlc.c#L467-L469

## Unsolved

 - what to do about "SD categories"? I just [ignore] them for now.
 - â€¦

[ignore]: src/media_browser/media_browser.c#L66

## Next steps

Here are the next steps I consider (not necessarily in this order):
 - refactor/merge [`vlc_services_discovery.h`][vlc_services_discovery.h] with
   the _media source manager_ (maybe?)
 - implement a new UI for _services discovery_ that will use media trees (for
   both Qt and MacOS-specific gui)
 - remove all remaining SD-stuff used to display SD in the current UI
 - refactor the preparser outside the playlist

 [vlc_services_discovery.h]: include/vlc_services_discovery.h

Thank you for your feedbacks ;-)
